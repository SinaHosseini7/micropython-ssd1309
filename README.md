# micropython-ssd1309

MicroPython driver for SSD1309 OLED displays on Raspberry Pi Pico 2 (RP2350) and Pico (RP2040)

![License](https://img.shields.io/badge/license-MIT-blue.svg)
![MicroPython](https://img.shields.io/badge/MicroPython-v1.20%2B-green.svg)
![Platform](https://img.shields.io/badge/platform-Raspberry%20Pi%20Pico%202%20(RP2350)-red.svg)
![Platform](https://img.shields.io/badge/platform-Raspberry%20Pi%20Pico%20(RP2040)-red.svg)
![Version](https://img.shields.io/badge/version-v1.0.0-orange.svg)
![GitHub stars](https://img.shields.io/github/stars/SinaHosseini7/micropython-ssd1309?style=social)
![GitHub forks](https://img.shields.io/github/forks/SinaHosseini7/micropython-ssd1309?style=social)

---

## Features

### Display Capabilities
- High-speed SPI interface (10MHz maximum)
- Multiple resolution support (128x64, 128x32)
- Monochrome display with multiple color options (white/yellow/blue/green)
- Full FrameBuffer support with all standard drawing methods
- Hardware scrolling support (inherited from FrameBuffer)

### Performance & Optimization
- **< 2ms refresh time at 10MHz SPI (500+ FPS capable)**
- Single-transaction buffer writes for optimal speed
- Minimal CPU overhead during display updates
- Efficient memory usage (1024 bytes for 128x64)
- Optimized command sequences for fast initialization

### Driver Quality
- Production-grade error handling
- Clean `framebuf.FrameBuffer` inheritance
- Comprehensive docstrings with examples
- Type hints for all methods
- No external dependencies (standard MicroPython only)
- Robust reset and addressing pointer management
- Thread-safety notes for RP2350 dual-core usage

### Drawing Capabilities
- All framebuf methods: `pixel()`, `line()`, `hline()`, `vline()`
- Rectangles: `rect()` (outline), `fill_rect()` (filled)
- Text rendering with built-in 8x8 font
- Contrast control (0-255)
- Display inversion (normal/inverted)
- Power management (on/off)
- Custom shapes via pixel manipulation

---

## Hardware Requirements

### Supported Platforms
- **Raspberry Pi Pico 2 (RP2350)** — Primary platform
- **Raspberry Pi Pico (RP2040)** — Fully compatible
- Any RP2040/RP2350-based board with SPI support

### Display Module
- **SSD1309-based OLED displays** (2.42-inch common)
- Model example: SFOM242YZ7-12864WBYG-01 (Saef Technology)
- Controller IC: SSD1309 / SPD0301 (Solomon Systech)
- Resolution: 128x64 or 128x32 pixels (Monochrome)
- Interface: 7-pin SPI (4-wire SPI + CS + DC + RST)

### SPI Configuration
- Any GPIO pins can be used (examples use GP18/19/20/16/17)
- Maximum SPI speed: 10MHz (datasheet: 100ns minimum clock cycle)
- SPI Mode 0 (CPOL=0, CPHA=0)

### Power Supply
- Logic Voltage: 3.3V (modules have onboard LDO regulator)
- Panel Voltage: 8-17V (generated by onboard DC-DC boost converter)

> ⚠️ **CRITICAL: GPIO 16 Conflict**
>
> GPIO 16 is the default `SPI0 RX` (MISO) pin on the Pico. If you use GPIO 16 for the DC pin (as shown in examples), you **MUST** initialize SPI with `miso=None` to prevent the SPI peripheral from taking control of GPIO 16. Failure to do this will cause display malfunction.

---

## Wiring Diagram

```
Raspberry Pi Pico 2              SSD1309 OLED Module
─────────────────────            ────────────────────
3V3 (Pin 36)         ─────────── VDD (3.3V Power)
GND (Pin 38)         ─────────── GND (Ground)
GPIO 18 (Pin 24)     ─────────── SCK (SPI Clock)
GPIO 19 (Pin 25)     ─────────── SDA (SPI MOSI)
GPIO 20 (Pin 26)     ─────────── RST (Reset)
GPIO 16 (Pin 21)     ─────────── DC  (Data/Command)  ⚠️ See note below
GPIO 17 (Pin 22)     ─────────── CS  (Chip Select)
```

### Pin Mapping Table

| Module Pin | Function       | Pico 2 GPIO | Physical Pin | Notes                           |
|------------|----------------|-------------|--------------|----------------------------------|
| **GND**    | Ground         | GND         | 38           | Common ground                   |
| **VDD**    | Logic Power    | 3.3V        | 36           | 3.3V supply                     |
| **SCK**    | SPI Clock      | GPIO 18     | 24           | SPI0 SCK                        |
| **SDA**    | SPI MOSI       | GPIO 19     | 25           | SPI0 TX                         |
| **RST**    | Reset          | GPIO 20     | 26           | Active LOW                      |
| **DC**     | Data/Command   | GPIO 16     | 21           | ⚠️ Requires `miso=None` in SPI  |
| **CS**     | Chip Select    | GPIO 17     | 22           | Active LOW                      |

> **Note:** Any GPIO pins can be used for SPI. Adjust the `Pin()` numbers in your code accordingly. However, if you use GPIO 16 for DC, you must initialize SPI with `miso=None`.

---

## Installation

### Step 1: Ensure MicroPython is Installed
Install MicroPython v1.20+ on your Raspberry Pi Pico. Download from [micropython.org](https://micropython.org/download/RPI_PICO2/) for Pico 2 or [micropython.org](https://micropython.org/download/RPI_PICO/) for Pico.

### Step 2: Download the Repository
```bash
git clone https://github.com/SinaHosseini7/micropython-ssd1309.git
```

### Step 3: Copy Driver Files to Your Pico
Copy these files to your Pico's root directory:
- `ssd1309.py` (required)
- `main.py` (optional, for testing)

**Methods to copy files:**
- **Thonny IDE:** File → Save As → MicroPython device
- **mpremote:** `mpremote cp ssd1309.py :ssd1309.py`
- **ampy:** `ampy put ssd1309.py`

---

## Quick Start

```python
import machine
from ssd1309 import SSD1309_SPI

# Initialize SPI with miso=None to avoid GPIO 16 conflict
spi = machine.SPI(0,
                  baudrate=10_000_000,
                  polarity=0,
                  phase=0,
                  sck=machine.Pin(18),
                  mosi=machine.Pin(19),
                  miso=None)  # CRITICAL: Avoid GPIO 16 conflict

# Initialize display
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16),
                   rst=machine.Pin(20),
                   cs=machine.Pin(17))

# Clear display and draw
oled.fill(0)                           # Clear to black
oled.rect(0, 0, 128, 64, 1)           # Draw border
oled.text("Hello SSD1309!", 8, 28, 1) # Draw text
oled.show()                            # Update display
```

---

## API Reference

### SSD1309_SPI Class

#### Constructor

```python
SSD1309_SPI(width, height, spi, dc, rst, cs)
```

Initialize the SSD1309 display with automatic hardware reset and command sequence.

**Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| `width` | int | Display width in pixels (128) |
| `height` | int | Display height in pixels (64 or 32) |
| `spi` | machine.SPI | Configured SPI bus object (must use `miso=None` if DC uses GPIO 16) |
| `dc` | machine.Pin | Data/Command selection pin |
| `rst` | machine.Pin | Hardware reset pin (active LOW) |
| `cs` | machine.Pin | Chip select pin (active LOW) |

**Raises:**
- `ValueError` — If width/height don't match supported display sizes (128x64 or 128x32)

**Example:**
```python
spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                  sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16),
                   rst=machine.Pin(20),
                   cs=machine.Pin(17))
```

---

#### Methods

**`reset()`**

Perform hardware reset sequence.

```python
oled.reset()
```

Pulls RST pin LOW for 10ms, then HIGH, followed by 10ms stabilization delay. This is called automatically during initialization.

---

**`init_display()`**

Initialize display with the complete command sequence.

```python
oled.init_display()
```

Sends the full SSD1309 initialization sequence including command unlock (0xFD, 0x12). Called automatically during initialization.

> **Note:** This method does NOT include the 0x8D charge pump command, which is SSD1306-specific and invalid for SSD1309.

---

**`show()`**

Transfer the framebuffer to the display.

```python
oled.fill(1)
oled.show()  # Display now shows white
```

**Critical:** This method resets addressing pointers (0x21, 0x22) before each buffer write to prevent wraparound artifacts from interrupted transactions. Always call `show()` after modifying the framebuffer.

**Performance:** At 10MHz SPI, achieves < 2ms refresh time for 128x64 display.

---

**`contrast(value)`**

Set display contrast (brightness).

```python
oled.contrast(128)  # 50% brightness
oled.contrast(255)  # Maximum brightness
oled.contrast(0)    # Minimum brightness
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `value` | int | Contrast level (0-255, default: 207) |

> **Note:** Values outside 0-255 are automatically clamped to valid range.

---

**`invert(invert)`**

Invert display colors.

```python
oled.invert(True)   # Inverted: black pixels become white
oled.invert(False)  # Normal: white pixels are white
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `invert` | bool | True for inverted, False for normal |

---

**`poweroff()`**

Put display into sleep mode (low power).

```python
oled.poweroff()
```

In sleep mode, the display is blanked and power consumption is significantly reduced. Framebuffer contents are preserved.

---

**`poweron()`**

Wake display from sleep mode.

```python
oled.poweron()
```

Restores display to normal operation after `poweroff()`.

---

**`fill(color)`** *(inherited from FrameBuffer)*

Fill the entire display with a color.

```python
oled.fill(0)  # Clear to black
oled.fill(1)  # Fill with white
oled.show()
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `color` | int | 0 for black (OFF), 1 for white (ON) |

---

**`pixel(x, y, color=None)`** *(inherited from FrameBuffer)*

Get or set a single pixel.

```python
oled.pixel(10, 20, 1)     # Set pixel at (10,20) to white
color = oled.pixel(10, 20) # Get pixel color at (10,20)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `x` | int | X coordinate (0 to width-1) |
| `y` | int | Y coordinate (0 to height-1) |
| `color` | int/None | If provided, sets pixel; if None, returns current color |

---

**`text(text, x, y, color)`** *(inherited from FrameBuffer)*

Draw text using the built-in 8x8 pixel font.

```python
oled.text("Hello!", 0, 0, 1)
oled.show()
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `text` | str | Text string to display |
| `x` | int | X position (left edge of text) |
| `y` | int | Y position (top edge of text) |
| `color` | int | 0 for black, 1 for white |

---

**`line(x1, y1, x2, y2, color)`** *(inherited from FrameBuffer)*

Draw a line between two points.

```python
oled.line(0, 0, 127, 63, 1)  # Diagonal line
oled.show()
```

---

**`hline(x, y, w, color)`** *(inherited from FrameBuffer)*

Draw a horizontal line.

```python
oled.hline(0, 32, 128, 1)  # Horizontal line across middle
```

---

**`vline(x, y, h, color)`** *(inherited from FrameBuffer)*

Draw a vertical line.

```python
oled.vline(64, 0, 64, 1)  # Vertical line down center
```

---

**`rect(x, y, w, h, color)`** *(inherited from FrameBuffer)*

Draw a rectangle outline.

```python
oled.rect(10, 10, 50, 30, 1)  # Rectangle outline
oled.show()
```

---

**`fill_rect(x, y, w, h, color)`** *(inherited from FrameBuffer)*

Draw a filled rectangle.

```python
oled.fill_rect(10, 10, 50, 30, 1)  # Filled rectangle
oled.show()
```

---

#### Properties (Read-Only)

| Property | Type | Description |
|----------|------|-------------|
| `width` | int | Display width in pixels (128) |
| `height` | int | Display height in pixels (64 or 32) |
| `buffer` | bytearray | Framebuffer storage (1024 bytes for 128x64) |

---

## Important Notes

### SPI Configuration Critical

GPIO 16 is the default SPI0 RX (MISO) pin on the Raspberry Pi Pico. Since SSD1309 displays use SPI in write-only mode (no MISO needed), you can safely use GPIO 16 for the DC pin—but only if you initialize SPI correctly:

```python
# ✓ CORRECT: miso=None prevents SPI from claiming GPIO 16
spi = machine.SPI(0,
                  baudrate=10_000_000,
                  polarity=0,
                  phase=0,
                  sck=machine.Pin(18),
                  mosi=machine.Pin(19),
                  miso=None)  # CRITICAL

# ✗ WRONG: Omitting miso parameter lets SPI claim GPIO 16
spi = machine.SPI(0, baudrate=10_000_000)  # GPIO 16 conflict!
```

**Consequences of incorrect initialization:** The DC pin will not function properly, resulting in garbled display or no output.

### Performance Optimization

The driver achieves exceptional performance through several optimizations:

1. **Single-transaction writes:** The entire 1024-byte framebuffer is sent in one `spi.write()` call
2. **Addressing reset:** Column and page addresses are reset before each write to prevent artifacts
3. **No unnecessary commands:** The initialization sequence is minimal and efficient

**Typical Performance Metrics (128x64 at 10MHz SPI):**
- Refresh time: ~1.5-2ms per frame
- Maximum FPS: 500-670 FPS (theoretical)
- Practical animation: 60+ FPS easily achievable

To measure performance on your hardware:
```python
import time

def measure_refresh_rate(oled, iterations=100):
    oled.fill(1)
    oled.show()
    
    start = time.ticks_us()
    for _ in range(iterations):
        oled.show()
    elapsed_us = time.ticks_diff(time.ticks_us(), start)
    
    avg_time_ms = (elapsed_us / iterations) / 1000
    max_fps = 1000 / avg_time_ms
    print(f"Average frame time: {avg_time_ms:.2f} ms")
    print(f"Maximum FPS: {max_fps:.1f}")
```

### Resolution Support

The driver supports two common SSD1309 display resolutions:

| Resolution | Buffer Size | Pages | Common Display Size |
|------------|-------------|-------|---------------------|
| 128x64 | 1024 bytes | 8 | 2.42 inch, 1.3 inch |
| 128x32 | 512 bytes | 4 | 0.91 inch |

For 128x32 displays, simply change the height parameter:
```python
oled = SSD1309_SPI(128, 32, spi, dc=dc, rst=rst, cs=cs)
```

### Display Orientation

To flip or mirror the display, modify the initialization commands in `ssd1309.py`:

| Orientation Change | Command Modification |
|--------------------|---------------------|
| Flip vertically | Change `0xC8` to `0xC0` |
| Mirror horizontally | Change `0xA1` to `0xA0` |
| Garbled lines fix | Change COM pins `0x12` to `0x02` |

---

## Advanced Usage Examples

### Error Handling

```python
import machine
from ssd1309 import SSD1309_SPI

try:
    spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                      sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
    
    oled = SSD1309_SPI(128, 64, spi,
                       dc=machine.Pin(16),
                       rst=machine.Pin(20),
                       cs=machine.Pin(17))
    print("Display initialized successfully!")
    
except ValueError as e:
    print(f"Invalid display configuration: {e}")
except OSError as e:
    print(f"Hardware communication error: {e}")
    print("Check wiring and connections")
```

### Dual-Core Graphics (RP2350)

```python
import _thread
import time
import machine
from ssd1309 import SSD1309_SPI

# Initialize display
spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                  sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16), rst=machine.Pin(20), cs=machine.Pin(17))

# Thread synchronization lock
display_lock = _thread.allocate_lock()

# Shared state
frame_count = 0

def core1_animation():
    """Background animation task on Core 1."""
    global frame_count
    x = 0
    direction = 1
    
    while True:
        with display_lock:
            oled.fill(0)
            oled.fill_rect(x, 28, 8, 8, 1)  # Moving square
            oled.text(f"Frame: {frame_count}", 0, 0, 1)
            oled.show()
            frame_count += 1
        
        x += direction * 2
        if x <= 0 or x >= 120:
            direction = -direction
        
        time.sleep_ms(16)  # ~60 FPS

# Start Core 1 task
_thread.start_new_thread(core1_animation, ())

# Core 0 can do other work...
while True:
    time.sleep(1)
    print(f"Frames rendered: {frame_count}")
```

### Performance Monitoring

```python
import time
import machine
from ssd1309 import SSD1309_SPI

spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                  sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16), rst=machine.Pin(20), cs=machine.Pin(17))

def draw_fps_counter():
    """Real-time FPS counter on display."""
    frame_count = 0
    start_time = time.ticks_ms()
    
    while True:
        # Calculate FPS
        elapsed = time.ticks_diff(time.ticks_ms(), start_time)
        if elapsed >= 1000:
            fps = frame_count * 1000 / elapsed
            frame_count = 0
            start_time = time.ticks_ms()
        else:
            fps = frame_count * 1000 / max(elapsed, 1)
        
        # Draw
        oled.fill(0)
        oled.rect(0, 0, 128, 64, 1)
        oled.text(f"FPS: {fps:.1f}", 32, 28, 1)
        oled.show()
        
        frame_count += 1

draw_fps_counter()
```

### Smooth Animation

```python
import time
import machine
from ssd1309 import SSD1309_SPI

spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                  sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16), rst=machine.Pin(20), cs=machine.Pin(17))

def bouncing_ball():
    """Smooth bouncing ball animation."""
    x, y = 64.0, 32.0
    vx, vy = 2.5, 1.8
    radius = 6
    
    while True:
        # Clear and draw
        oled.fill(0)
        oled.rect(0, 0, 128, 64, 1)
        
        # Draw filled circle (approximation)
        cx, cy = int(x), int(y)
        for dy in range(-radius, radius + 1):
            dx = int((radius * radius - dy * dy) ** 0.5)
            oled.hline(cx - dx, cy + dy, 2 * dx + 1, 1)
        
        oled.show()
        
        # Update physics
        x += vx
        y += vy
        
        # Bounce off walls
        if x <= radius or x >= 127 - radius:
            vx = -vx
            x = max(radius, min(127 - radius, x))
        if y <= radius or y >= 63 - radius:
            vy = -vy
            y = max(radius, min(63 - radius, y))

bouncing_ball()
```

### Progress Bar

```python
import time
import machine
from ssd1309 import SSD1309_SPI

spi = machine.SPI(0, baudrate=10_000_000, polarity=0, phase=0,
                  sck=machine.Pin(18), mosi=machine.Pin(19), miso=None)
oled = SSD1309_SPI(128, 64, spi,
                   dc=machine.Pin(16), rst=machine.Pin(20), cs=machine.Pin(17))

def draw_progress_bar(progress, message="Loading..."):
    """Draw a progress bar with message."""
    oled.fill(0)
    oled.rect(0, 0, 128, 64, 1)
    
    # Center text
    text_x = (128 - len(message) * 8) // 2
    oled.text(message, text_x, 12, 1)
    
    # Progress bar
    bar_x, bar_y = 10, 32
    bar_w, bar_h = 108, 16
    
    oled.rect(bar_x, bar_y, bar_w, bar_h, 1)
    fill_w = int((bar_w - 4) * progress / 100)
    if fill_w > 0:
        oled.fill_rect(bar_x + 2, bar_y + 2, fill_w, bar_h - 4, 1)
    
    # Percentage
    pct_text = f"{progress}%"
    pct_x = (128 - len(pct_text) * 8) // 2
    oled.text(pct_text, pct_x, 52, 1)
    
    oled.show()

# Demo
for i in range(0, 101, 2):
    draw_progress_bar(i)
    time.sleep_ms(50)
```

---

## Troubleshooting

| Problem | Possible Cause | Solution |
|---------|---------------|----------|
| Blank screen | No power | Verify VDD = 3.3V and GND connections |
| Blank screen | Wrong SPI wiring | Check MOSI on GPIO 19, SCK on GPIO 18 |
| Blank screen | RST not toggling | Ensure RST pin is connected to GPIO 20 |
| Blank screen | Missing command unlock | Verify driver sends 0xFD, 0x12 after reset |
| Blank screen | Low contrast | Try `oled.contrast(255)` |
| Upside-down display | COM scan direction | Change init command 0xC8 to 0xC0 |
| Mirror image (horizontally flipped) | Segment remap | Change init command 0xA1 to 0xA0 |
| Garbled / interleaved lines | Wrong COM pins config | Change 0xDA parameter from 0x12 to 0x02 |
| Slow refresh (> 15ms) | Low SPI speed | Verify baudrate is 10_000_000 |
| Slow refresh (> 15ms) | MISO conflict | Ensure `miso=None` in SPI init |
| Random pixels / artifacts | Interrupted SPI | Ensure `show()` sends addressing commands first |
| Random pixels / artifacts | Loose wiring | Check connections, use shorter wires |
| Display glitches / bit errors | Signal integrity | Lower SPI speed to 8MHz or 4MHz |
| Display glitches / bit errors | Breadboard issues | Use better breadboard or solder connections |
| GPIO 16 not working as DC | MISO conflict | Initialize SPI with `miso=None` |
| RP2350 dual-core crashes | Race condition | Wrap display access with `_thread.allocate_lock()` |
| No I2C devices found | Wrong interface | This driver is SPI only, not I2C |

---

## File Structure

```
your-project/
├── ssd1309.py         # SSD1309 driver (required)
├── main.py            # Example demonstrations
├── LICENSE            # MIT License
└── README.md          # This file
```

---

## Technical Specifications

### SSD1309 Display Specifications

| Parameter | Value | Notes |
|-----------|-------|-------|
| Resolution | 128x64 or 128x32 | Monochrome |
| Display Size | 2.42" (common) | Varies by module |
| Active Area | 55.01 × 27.5 mm | For 2.42" module |
| Pixel Pitch | 0.43 × 0.43 mm | For 2.42" module |
| Contrast Ratio | 2000:1 (typical) | High contrast OLED |
| Viewing Angle | 160° | All directions |
| Operating Temp | -40°C to +70°C | Industrial range |
| Response Time | < 10 µs | Very fast |
| Interface | 4-wire SPI | Up to 10MHz |
| Logic Voltage | 3.3V | Via onboard LDO |
| Display Colors | White, Yellow, Blue, Green | One color per module |

### Performance Metrics

| Parameter | 128x64 | 128x32 |
|-----------|--------|--------|
| Buffer Size | 1024 bytes | 512 bytes |
| Pages | 8 | 4 |
| Refresh @ 10MHz | ~1.5 ms | ~0.8 ms |
| Max Theoretical FPS | ~670 | ~1250 |
| Practical FPS | 60+ | 60+ |
| Memory Footprint | ~2KB total | ~1.5KB total |

---

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

### Guidelines
- Follow the existing code style
- Add tests for new features
- Update documentation as needed
- Ensure all tests pass before submitting

### Reporting Issues
- Use GitHub Issues for bug reports and feature requests
- Include MicroPython version and hardware details
- Provide minimal code to reproduce the issue

---

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## Acknowledgments

- Solomon Systech for the SSD1309 controller IC and comprehensive datasheet
- Raspberry Pi Foundation for the excellent Pico/Pico 2 platforms
- MicroPython community for the excellent embedded Python implementation
- Thanks to Claude Opus 4.5 for code optimization and documentation assistance

---

## References

### Datasheets
- [SSD1309 Datasheet (Solomon Systech)](https://www.solomon-systech.com/product/ssd1309/)
- [Raspberry Pi Pico 2 Documentation](https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html)
- [Raspberry Pi Pico Documentation](https://www.raspberrypi.com/documentation/microcontrollers/pico-series.html)

### Where to Buy
- Search for "SSD1309 OLED 128x64" on Amazon or AliExpress
- Search for "2.42 inch OLED SSD1309" for common modules
- Waveshare 2.42" OLED Module
- Saef Technology SFOM242YZ7 series
- Various electronics suppliers (Adafruit, SparkFun, DFRobot carry similar modules)

### Related Projects
- [rdagger/micropython-ssd1309](https://github.com/rdagger/micropython-ssd1309) — More feature-rich alternative with custom fonts, sprites, and image support. This driver focuses on simplicity and performance with clean FrameBuffer integration. For advanced graphics features like custom fonts and sprites, see rdagger's comprehensive SSD1309 library.

### Related Resources
- [MicroPython Official Documentation](https://docs.micropython.org/)
- [MicroPython FrameBuffer Documentation](https://docs.micropython.org/en/latest/library/framebuf.html)
- [Raspberry Pi Pico Documentation](https://www.raspberrypi.com/documentation/microcontrollers/)
- [MicroPython Forum](https://forum.micropython.org/)

---

## Author

**GitHub:** [@SinaHosseini7](https://github.com/SinaHosseini7)

If you find this project helpful, please consider giving it a ⭐ on GitHub!
